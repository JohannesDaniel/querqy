/**
 * 
 */
package querqy.lucene.rewrite;

import java.io.IOException;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import org.apache.commons.io.input.CharSequenceReader;
import org.apache.lucene.analysis.Analyzer;
import org.apache.lucene.analysis.TokenStream;
import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
import org.apache.lucene.search.BooleanClause.Occur;
import org.apache.lucene.search.Query;
import org.apache.lucene.util.BytesRef;

import querqy.CompoundCharSequence;
import querqy.lucene.rewrite.BooleanQueryFactory.Clause;
import querqy.lucene.rewrite.cache.CacheKey;
import querqy.lucene.rewrite.cache.TermQueryCache;
import querqy.lucene.rewrite.cache.TermQueryCacheValue;
import querqy.model.AbstractNodeVisitor;
import querqy.model.BooleanQuery;
import querqy.model.DisjunctionMaxQuery;
import querqy.model.Term;
import querqy.rewrite.commonrules.model.PositionSequence;

/**
 * @author Ren√© Kriegler, @renekrie
 *
 */
public class LuceneQueryBuilder extends AbstractNodeVisitor<LuceneQueryFactory<?>> {

   enum ParentType {
      BQ, DMQ
   }

   final Analyzer analyzer;
   final Map<String, Float> queryFieldsAndBoostings;
   final Map<String, Float> generatedQueryFieldsAndBoostings;
   final boolean normalizeBooleanQueryBoost;
   final float dmqTieBreakerMultiplier;
   final float defaultGeneratedFieldBoostFactor;
   final DocumentFrequencyCorrection dfc;
   final TermQueryCache termQueryCache;

   LinkedList<BooleanQueryFactory> clauseStack = new LinkedList<>();
   LinkedList<DisjunctionMaxQueryFactory> dmqStack = new LinkedList<>();
   boolean useBooleanQueryForDMQ = false;

   protected ParentType parentType = ParentType.BQ;

   public LuceneQueryBuilder(DocumentFrequencyCorrection dfc, Analyzer analyzer,
           Map<String, Float> queryFieldsAndBoostings,  Map<String, Float> generatedQueryFieldsAndBoostings,
           float generatedFieldBoostFactor, float dmqTieBreakerMultiplier, TermQueryCache termQueryCache) {
      this(   
              dfc, 
              analyzer, 
              queryFieldsAndBoostings, 
              generatedQueryFieldsAndBoostings, 
              generatedFieldBoostFactor, 
              dmqTieBreakerMultiplier, 
              true, 
              termQueryCache);
   }

   /**
    * <p>Field names and boost factors are applied like this:</p>
    * <p>If a term doesn't already have a field name, generate all term queries for all fields and boost factors
    * from generatedQueryFieldsAndBoostings - if the term was generated by some rewriter - or from queryFieldsAndBoostings
    * otherwise.</p>
    * <p>If a term already has a field name use the boost factor for this field from generatedQueryFieldsAndBoostings if
    * the term was generated, and from queryFieldsAndBoostings otherwise. If the respective map doesn't contain the field,
    * use the defaultGeneratedFieldBoostFactor for generated terms. If the term is not generated, treat the field name as
    * part of the term text (= "fieldname:value").</p>
    * 
    * @param dfc
    * @param analyzer
    * @param queryFieldsAndBoostings Query fields and boostings for non-generated terms
    * @param generatedQueryFieldsAndBoostings Query fields and boostings for generated terms 
    * @param defaultGeneratedFieldBoostFactor Default boost factor for generated fields
    * @param dmqTieBreakerMultiplier
    * @param normalizeBooleanQueryBoost
    * @param termQueryCache The term query cache or null
    */
   public LuceneQueryBuilder(DocumentFrequencyCorrection dfc, Analyzer analyzer,
         Map<String, Float> queryFieldsAndBoostings,  
         Map<String, Float> generatedQueryFieldsAndBoostings, 
         float defaultGeneratedFieldBoostFactor,
         float dmqTieBreakerMultiplier, boolean normalizeBooleanQueryBoost, TermQueryCache termQueryCache) {
       
      this.analyzer = analyzer;
      this.queryFieldsAndBoostings = queryFieldsAndBoostings;
      this.generatedQueryFieldsAndBoostings = generatedQueryFieldsAndBoostings;
      this.dmqTieBreakerMultiplier = dmqTieBreakerMultiplier;
      this.normalizeBooleanQueryBoost = normalizeBooleanQueryBoost;
      this.defaultGeneratedFieldBoostFactor = defaultGeneratedFieldBoostFactor;
      this.dfc = dfc;
      this.termQueryCache = termQueryCache;
   }

   public void reset() {
      clauseStack.clear();
      dmqStack.clear();
      useBooleanQueryForDMQ = false;
   }

   public Query createQuery(querqy.model.Query query, boolean useBooleanQueryForDMQ) throws IOException {
       boolean tmp = this.useBooleanQueryForDMQ;
       try {
           this.useBooleanQueryForDMQ = useBooleanQueryForDMQ;
           return visit(query).createQuery(null, dmqTieBreakerMultiplier, dfc, false);
       } finally {
           this.useBooleanQueryForDMQ = tmp;
       }
   }
   
   public Query createQuery(querqy.model.Query query) throws IOException {
      return visit(query).createQuery(null, dmqTieBreakerMultiplier, dfc, false);
   }

   @Override
   public LuceneQueryFactory<?> visit(querqy.model.Query query) {
      parentType = ParentType.BQ;
      return visit((BooleanQuery) query);
   }

   @Override
   public LuceneQueryFactory<?> visit(BooleanQuery booleanQuery) {

      BooleanQueryFactory bq = new BooleanQueryFactory(
              booleanQuery.isGenerated(), 
              normalizeBooleanQueryBoost && parentType == ParentType.DMQ); 
      
      ParentType myParentType = parentType;
      parentType = ParentType.BQ;

      clauseStack.add(bq);
      super.visit(booleanQuery);
      clauseStack.removeLast();

      parentType = myParentType;

      Clause result = null;

      switch (bq.getNumberOfClauses()) {
      case 0:
       // no sub-query - this can happen if analysis filters out all tokens (stopwords) 
          return new NeverMatchQueryFactory();
      case 1:
          result = bq.getFirstClause();
          break;
      default:
          result = new Clause(bq, occur(booleanQuery.occur));
      }

      switch (parentType) {
      case BQ:
         if (!clauseStack.isEmpty()) {
            clauseStack.getLast().add(result);
            return bq;
         } else {// else we are the top BQ
            return result.queryFactory;
         }
      case DMQ:
         if (result.occur != Occur.SHOULD) {
            // create a wrapper query
            BooleanQueryFactory wrapper = new BooleanQueryFactory(true, false);
            wrapper.add(result);
            bq = wrapper;
         }
         dmqStack.getLast().add(bq);
         return bq;

      default:
         throw new RuntimeException("Unknown parentType " + parentType);
      }
   }

   protected Occur occur(querqy.model.SubQuery.Occur occur) {
      switch (occur) {
      case MUST:
         return Occur.MUST;
      case MUST_NOT:
         return Occur.MUST_NOT;
      case SHOULD:
         return Occur.SHOULD;
      }
      throw new IllegalArgumentException("Cannot handle occur value: " + occur.name());
   }

   @Override
   public LuceneQueryFactory<?> visit(DisjunctionMaxQuery disjunctionMaxQuery) {

      ParentType myParentType = parentType;
      parentType = ParentType.DMQ;

      DisjunctionMaxQueryFactory dmq = new DisjunctionMaxQueryFactory(); 

      dmqStack.add(dmq);
      super.visit(disjunctionMaxQuery);
      dmqStack.removeLast();

      parentType = myParentType;

      switch (dmq.getNumberOfDisjuncts()) {
      case 0:
         // no sub-query - this can happen if analysis filters out all tokens (stopwords) 
         return new NeverMatchQueryFactory();
      case 1:
         LuceneQueryFactory<?> firstDisjunct = dmq.getFirstDisjunct();
         clauseStack.getLast().add(firstDisjunct, occur(disjunctionMaxQuery.occur));
         return firstDisjunct;
      default:
         // FIXME: we can decide this earlier --> avoid creating DMQ in case of
         // MUST_NOT
          boolean useBQ = this.useBooleanQueryForDMQ || (disjunctionMaxQuery.occur == querqy.model.SubQuery.Occur.MUST_NOT);
              
         if (useBQ) {
            // FIXME: correct to normalize boost?
            BooleanQueryFactory bq = new BooleanQueryFactory(true, false);
            for (LuceneQueryFactory<?> queryFactory : dmq.disjuncts) {
               bq.add(queryFactory, Occur.SHOULD);
            }
            clauseStack.getLast().add(bq, occur(disjunctionMaxQuery.occur));
            return bq;
         }

         clauseStack.getLast().add(dmq, occur(disjunctionMaxQuery.occur));
         return dmq;
      }
   }

   @Override
   public LuceneQueryFactory<?> visit(Term term) {

      DisjunctionMaxQueryFactory siblings = dmqStack.getLast();
      String fieldname = term.getField();

      try {

          Map<String, Float> searchFieldsAndBoostings = (term.isGenerated()) ? generatedQueryFieldsAndBoostings : queryFieldsAndBoostings;

          if (fieldname != null) {
             
            Float boost = searchFieldsAndBoostings.get(fieldname);
            if (boost != null) {
                addTerm(fieldname, boost, siblings, term);
            } else if (term.isGenerated()) {
                addTerm(fieldname, defaultGeneratedFieldBoostFactor, siblings, term);
            } else {
               // someone searches in a field that is not set as a search field
               // --> set value to fieldname + ":" + value in search in all
               // fields
               Term termWithFieldInValue = new Term(null, new CompoundCharSequence(":", fieldname, term.getValue()));
               for (Map.Entry<String, Float> field : searchFieldsAndBoostings.entrySet()) {
                  addTerm(field.getKey(), field.getValue(), siblings, termWithFieldInValue);
               }
            }
         } else {
             for (Map.Entry<String, Float> field : searchFieldsAndBoostings.entrySet()) {
                 addTerm(field.getKey(), field.getValue(), siblings, term);
             }
         }
      } catch (IOException e) {
         // REVISIT: throw more specific exception?
         // - or save exception in Builder and then throw IOException from
         // build()
         throw new RuntimeException(e);
      }

      return null;

   }

   /**
    * 
    * <p>
    * Applies analysis to a term and adds the result to the Lucene query factory
    * tree.
    * </p>
    * 
    * <p>
    * The analysis might emit multiple tokens for the input term. If these
    * tokens constitute a sequence (according to the position attribute), a
    * BooleanQuery will be created and each position in the sequence constitutes
    * a MUST clause of this BooleanQuery. If multiple tokens occur at the same
    * position, a DismaxQuery will be created in this position and the tokens
    * constitute its disjuncts. The tiebreak factor will be set to the
    * dmqTieBreakerMultiplier property of this LuceneQueryBuilder.
    * </p>
    * 
    * 
    * @param fieldname
    * @param boost
    * @param target
    * @param sourceTerm
    * @throws IOException
    */
    void addTerm(String fieldname, float boost, DisjunctionMaxQueryFactory target, Term sourceTerm) throws IOException {
        LuceneQueryFactory<?> queryFactory = termToFactory(fieldname, sourceTerm, boost);
        if (queryFactory != null) {
            target.add(queryFactory);
        }
   }
    
    public TermSubQueryFactory termToFactory(String fieldname, Term sourceTerm, float boost) throws IOException {
        
        CacheKey cacheKey = null;

        if (termQueryCache != null) {
            
            cacheKey = new CacheKey(fieldname, sourceTerm);
           
            TermQueryCacheValue cacheValue = termQueryCache.get(cacheKey);
            if (cacheValue != null) {
                return (cacheValue.hasQuery()) ? new TermSubQueryFactory(cacheValue.queryFactory, boost) : null;
            } 
            
        }
        
        LuceneQueryFactory<? extends Query> clause = null;
        TokenStream ts = null;
        try {
           
           ts = analyzer.tokenStream(fieldname, new CharSequenceReader(sourceTerm));
           CharTermAttribute termAttr = ts.addAttribute(CharTermAttribute.class);
           PositionIncrementAttribute posIncAttr = ts.addAttribute(PositionIncrementAttribute.class);
           ts.reset();
         
           PositionSequence<org.apache.lucene.index.Term> sequence = new PositionSequence<>();
           while (ts.incrementToken()) {

               int inc = posIncAttr.getPositionIncrement();
               if (inc > 0 || sequence.isEmpty()) {
                   sequence.nextPosition();
               }

               sequence.addElement(new org.apache.lucene.index.Term(fieldname, new BytesRef(termAttr)));
           }

           switch (sequence.size()) {
           case 0: break;
           case 1: clause = getLuceneQueryFactoryForStreamPosition(sequence.getFirst());
                   break;
           default:
               BooleanQueryFactory bq = new BooleanQueryFactory(true, true);
               for (List<org.apache.lucene.index.Term> posTerms : sequence) {
                   bq.add(getLuceneQueryFactoryForStreamPosition(posTerms), Occur.MUST);
               }
               clause = bq;
           }

        } finally {
           if (ts != null) {
               try {
                   ts.close();
               } catch (IOException e) {
               }
           }
        }
        
        if (cacheKey != null) {
            termQueryCache.put(cacheKey, new TermQueryCacheValue(clause));
        }
        
        return clause == null ? null : new TermSubQueryFactory(clause, boost);
    }

   protected LuceneQueryFactory<?> getLuceneQueryFactoryForStreamPosition(List<org.apache.lucene.index.Term> posTerms) {
      if (posTerms.size() == 1) {
         return new TermQueryFactory(posTerms.get(0));
      } else {
         DisjunctionMaxQueryFactory dmq = new DisjunctionMaxQueryFactory();
         for (org.apache.lucene.index.Term term : posTerms) {
            dmq.add(new TermQueryFactory(term));
         }
         return dmq;
      }
   }

}
